<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>思路：造一个最简单的能执行程序的计算机 - peijie&#39;s wiki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,思考,技术,博客>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="peijie&#39;s wiki" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">


	<link
    rel="stylesheet"
    href="https://unpkg.com/@waline/client@v2/dist/waline.css"
  />
<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">peijie&#39;s wiki</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/contact" class="menu-item-link">Contact</a>
        </li>
      
        <li class="menu-item">
          <a target="_blank" rel="noopener" href="https://github.com/brannua" class="menu-item-link">GitHub</a>
        </li>
      
        <li class="menu-item">
          <a target="_blank" rel="noopener" href="https://travellings.link" class="menu-item-link">Travelling</a>
        </li>
      
        <li class="menu-item">
          <a target="_blank" rel="noopener" href="https://foreverblog.cn/go.html" class="menu-item-link">WormHole</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">RSS</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">思路：造一个最简单的能执行程序的计算机</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-04-19</span>
  </div>
  <div class="post-content">
    <h4 id="故事起源"><a href="#故事起源" class="headerlink" title="故事起源"></a>故事起源</h4><ul>
<li>先驱想创造一个能执行程序的计算机，让我们来帮助他</li>
</ul>
<h4 id="开始构思-！"><a href="#开始构思-！" class="headerlink" title="开始构思 ！"></a>开始构思 ！</h4><ul>
<li>我们知道，程序是由（代码 &amp; 数据）组成的</li>
<li>比如：假设我们想要计算<code>1+2+3+...+100</code>，那么我们不费吹灰之力就能写一个程序来完成这件事</li>
<li>不难理解：<ol>
<li>数据是程序处理的对象</li>
<li>代码描述了程序是如何对数据进行处理的</li>
</ol>
</li>
</ul>
<hr>
<blockquote>
<p>ok，既然我们想让计算机执行程序，那应该将程序放在哪儿呢 ？</p>
</blockquote>
<ul>
<li>程序有几十行代码的“小程序”，也有上万行代码的“大程序”（比如大型游戏程序）</li>
<li>显然，我们应该将程序放到一个<strong>拥有较大存储空间的“容器”</strong>中，这个容器叫：<strong>存储器</strong></li>
<li>于是，存储器诞生了，程序可被放入存储器中，等待着被 CPU 执行</li>
</ul>
<p><strong>等等，啥是 CPU ？</strong></p>
<ul>
<li>CPU，中文名叫<strong>中央处理器</strong>，听起来牛逼吧 ？！</li>
<li>嗯，它确实牛逼，它是<strong>负责处理数据的核心电路单元</strong>，程序执行全靠它</li>
<li>还不懂 ？<ul>
<li>你想啊，一个计算机它如果只有存储器，那还是不能计算嘛</li>
<li>所以就得 CPU 扛起计算的重任喽</li>
<li>咋扛呢 ？傻瓜，给 CPU 造运算器啊，然后就能对数据进行各种处理了</li>
<li>啥 ？你觉得运算器太复杂 ？</li>
<li>确实有点复杂哈，那就先只思考加法器吧～</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>仍然以计算<code>1+2+3+...+100</code>为例</li>
<li>对于本例，程序的编写方式是（将“部分”累加到“sum”上）</li>
</ul>
<blockquote>
<p>这就说明：有时候程序是需要对同一个数据进行连续的处理的</p>
</blockquote>
<ul>
<li><p>那么现在硬件视角的执行是下面这样的</p>
<ul>
<li>从存储器读出 sum 和 1，传入 CPU，1 被加到 sum 上，将 sum 写回存储器</li>
<li>从存储器读出 sum 和 2，传入 CPU，2 被加到 sum 上，将 sum 写回存储器</li>
<li>从存储器读出 sum 和 3，传入 CPU，3 被加到 sum 上，将 sum 写回存储器</li>
<li>…</li>
</ul>
</li>
<li><p>啊西巴 ！</p>
<ul>
<li>上面这样我们每完成一次累加都得将 sum 写回存储器，然后立刻就又将 sum 读出来继续加，这样太傻了啊</li>
</ul>
</li>
<li><p>为什么说上面这种方式很傻呢 ？你可以想像这样的场景：</p>
<ul>
<li>考试的时候你做一道题就向你同桌借一次橡皮，上道题做完你立马就还回去，下道题还借…</li>
<li>懂了吧 ？！</li>
</ul>
</li>
<li><p>另外，大容量的存储器的读写速度是相对较慢的，这是谁都无法违背的材料特性规律</p>
</li>
<li><p>于是先驱创造了小容量但高速的<strong>寄存器</strong>，CPU 正在处理中的数据可被暂放其中</p>
</li>
</ul>
<blockquote>
<p>至此，我们就有了（存储器、CPU、寄存器）</p>
</blockquote>
<p><img src="https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220410180257453.png" alt="image-20220410180257453"></p>
<ul>
<li>riscv-volume-1、riscv-volume-2 &#x3D;&#x3D;&gt; See 阿里云盘&#x2F;Books</li>
<li><a target="_blank" rel="noopener" href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a></li>
</ul>
<hr>
<ul>
<li><p>为了让强大的 CPU 成为我们忠实的奴仆，<strong>指令</strong>诞生了</p>
</li>
<li><p>我们可以用指令来控制 CPU，让 CPU 做我们想做的事</p>
</li>
<li><p>但（发一条指令，CPU 就动一动）的方式还是不尽人意，于是先驱就和 CPU 做了一个简单的约定</p>
<ul>
<li>给你一段程序，你执行完一条指令之后，就继续执行下一条指令</li>
<li>可 CPU 怎么知道现在执行到哪一条指令呢 ？</li>
<li>为此，先驱为 CPU 创造了<strong>程序计数器</strong>（Program Counter，PC）</li>
<li>在 x86 中，它有一个特殊的名字，叫（Extended Instruction Pointer，EIP）</li>
<li>从此，计算机就只需做一件事</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从 PC 指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新 PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>至此，我们就设计出了一个足够简单的计算机</p>
<p>只需将一段指令序列放入存储器，然后让 PC 指向第一条指令，这段指令序列就会被计算机自动执行～</p>
</blockquote>
<p>例如，下面的指令序列可以计算<code>1+2+...+100</code></p>
<p>其中<code>r1</code>和<code>r2</code>是两个寄存器，还有一个隐含的程序计数器<code>PC</code>，初值为<code>0</code></p>
<p>为了帮助大家理解, 我们把指令的语义翻译成 C 代码放在右侧，其中每一行 C 代码前都添加了一个语句标号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: mov  r1, 0         |  pc0: r1 = 0;</span><br><span class="line">1: mov  r2, 0         |  pc1: r2 = 0;</span><br><span class="line">2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;</span><br><span class="line">3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;</span><br><span class="line">4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;</span><br><span class="line">5: jmp 5              |  pc5: goto pc5;</span><br></pre></td></tr></table></figure>

<p>计算机执行以上的指令序列，最后会在 PC &#x3D; 5 的指令处陷入死循环，此时计算已经结束，<code>1+2+...+100</code>的结果会被存放在寄存器<code>r1</code>中</p>
<p><img src="https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220410183206046.png" alt="image-20220410183206046"></p>
<ul>
<li>事实上，开拓者图灵早在 1936 年就已经提出了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_Turing_machine/">类似的核心思想</a>，「计算机科学之父」果然名不虚传</li>
<li>而这个流传至今的核心思想，就是“存储程序” ！</li>
<li>为了表达对图灵的敬仰，我们将上面这个最简单的计算机称为「图灵机，Turing Machine，TRM」</li>
<li>或许你已经听说过图灵机这个作为计算模型时的概念</li>
<li>但这里我们只强调一个最简单的真实计算机需要满足哪些条件：<ol>
<li>结构上：TRM 有（存储器、PC、加法器、寄存器）</li>
<li>工作方式上：TRM 不断重复以下过程</li>
</ol>
<ul>
<li>从 PC 指示的存储器位置取出指令 &#x3D;&gt; 执行指令 &#x3D;&gt; 更新 PC</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>咦 ？（存储器、PC、加法器、寄存器）这些不都是数字逻辑电路课上学习过的部件吗 ？</li>
<li>也许你会觉得难以置信，但你正面对着的这台无所不能的计算机，就是由只懂 0 和 1 的数字逻辑电路组成的 ！</li>
</ul>
<blockquote>
<p>blame my 数字逻辑电路 teacher, blame myself.</p>
</blockquote>
<ul>
<li>可我们写的是 C 代码啊，这个冷冰冰的电路是如何理解凝结了人类智慧结晶的 C 代码的呢 ？</li>
<li>先驱说：“计算机诞生的那些年还没有 C 语言，大家当时都是直接编写对人类来说晦涩难懂的机器指令，这也是最早的对电子计算机的编程方式了”</li>
<li>后来人们发明了（高级语言 &amp; 编译器），我们能直接编写高级语言代码，经由编译器处理，生成功能等价的，且 CPU 能理解的指令</li>
<li>CPU 执行这些指令，就相当于执行了我们写的代码</li>
</ul>
<blockquote>
<p>如今的计算机本质上仍然是”存储程序”这种工作方式</p>
<p>经过了无数计算机科学家们的努力，才使得我们今天可以轻松地使用计算机</p>
</blockquote>
<p>（完）</p>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2025
  <span class="author">
    lpj
  </span>
</footer>

<div id="waline"></div>
<script type="module">
	import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

	init({
		el: '#waline',
		serverURL: 'https://comment.liupj.top',

		locale : {
			placeholder: '欢迎发表有意义的评论，正确填写【昵称】和【邮箱】是可以及时接收到回复通知的哦～'
		},
	});
</script>

    </div>
  </body>
</html>
